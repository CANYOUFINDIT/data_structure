### 目录

* [进程管理](#进程管理)
* [进程的组成](#进程的组成)
* [进程的状态](#进程的状态)
  * [三态模型](#三态模型)
  * [五态模型](#五态模型)
* [进程间的通信](#进程间的通信)
  * [同步与互斥](#同步与互斥)
    * [进程间的同步](#进程间的同步)
    * [进程间的互斥](#进程间的互斥)
    * [临界区管理的原则](#临界区管理的原则)
  * [信号量机制](#信号量机制)
    * [整形信号量与PV操作](#整形信号量与PV操作)
    * [利用PV操作实现进程的互斥](#利用PV操作实现进程的互斥)
* [死锁](#死锁)
  * [死锁的处理](#死锁的处理)
    * [死锁预防](#死锁预防)
    * [死锁避免](#死锁避免)
* [线程](#线程)

# 进程管理

进程管理也称处理机管理。在多道程序批处理系统和分时系统中有多个并发执行的程序，为了描述系统中程序执行时动态变化的过程引入了进程。进程是资源分配和独立运行的基本单位。进程管理重点需要研究诸进程之间的并发特性，以及进程之间相互合作与资源竞争产生的问题。

## 进程的组成

进程是程序的一次执行，该程序可以和其他程序并发执行。进程通常是由程序、数据和进程控制块(Process Control Block，PCB)组成。
 1. PCB：PCB是进程存在的唯一标志，其主要内容如下。
	- 进程标识符：标明系统中的各个进程
	- 状态：说明进程当前的状态
	- 位置信息：指明程序及数据在主存或外存的物理位置
	- 控制信息：参数、信号量、信息等
	- 队列指针：链接同一状态的进程
	- 优先级：进程调度的依据
	- 现场保护区：将处理机的现场保护到该区域，以便再次调度时能继续正确运行
	- 其他：因不同的系统而异
2. 程序：程序部分描述了进程需要完成的功能
3. 数据：数据部分包括程序执行时所需的数据及工作区

## 进程的状态

### 三态模型

多道程序系统中，进程在处理器上交替运行，状态也不断发生变化，因此进程一般有3种基本状态：**运行、就绪、阻塞。**
1. 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。显然，对于单处理机系统，处于运行状态的进程只有一个。
2. 就绪。一个进程获得了除处理机外的一切所需资源，一日得到处理机即可运行，则称此进程处于就绪状态。
3. 阻塞。阻塞也称等待或睡眠状态，一个 进程正在等待某一事件发生(例如请求IO等待I/O完成等)而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。
   
<div align=center>
<img src="https://img-blog.csdnimg.cn/20190326164346814.png" width="60%" height="60%" />
</div>

### 五态模型

由于进程的不断创建，系统资源特别是主存资源已不能满足进程运行的要求。这时，就必须将某些进程挂起，放到磁盘对换区，暂时不参加调度，以平衡系统负载。或者是系统出现故障，或者是用户调试程序，也可能需要将进程挂起检查问题。
1. 活跃就绪。活跃就绪是指进程在主存并且可被调度的状态。
2. 静止就绪。静止就绪是指就绪进程被对换到辅存时的状态，它是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起态进程具有更高的优先级时，系统将把挂起就绪态进程调回主存并转换为活跃就绪。
3. 活跃阻塞。活跃阻塞是指进程在主存，一旦等待的事件产生便进入活跃就绪状态。
4. 静止阻塞。静止阻塞是指阻塞进程对换到辅存时的状态，一 日等待的事件产生便进入静止就绪状态。

<div align=center>
<img src="https://img-blog.csdnimg.cn/20190326164619951.png" width="60%" height="60%" />
</div>


## 进程间的通信

在多道程序环境的系统中存在多个可以并发执行的进程，故进程间必然存在资源共享和相互合作的问题。进程通信是指各个进程交换信息的过程。

### 同步与互斥

同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题。

#### 进程间的同步

在计算机系统中，多个进程可以并发执行，每个进程都以各自独立的、不可预知的速度向前推进，但是需要在某些确定点上协调相互合作进程间的工作。例如，进程A向缓冲区送数据，进程B从缓冲区取数据加工，当进程B要取数据加工时，必须是进程A完成了向缓冲区送费据的操作，否则进程B必须停下来等待进程A的操作结束。

**可见，所谓进程间的同步是指在系统中一些需要相互合作， 协同工作的进程，这样的相互联系称为进程的同步**。

#### 进程间的互斥

**进程的互斥是指系统中多个进程因争用临界资源而互斥执行。** 在多道程序系统环境中，各进程可以共享各类资源，但有些资源次只能供一个进程使用，称为临界资源(Critical Resource, CR)，如打印机、共享变量和表格等。

#### 临界区管理的原则

临界区(Critical Section, CS)是进程中对临界资源实施操作的那段**程序**。对互斥临界区管理的4条原则如下。
1. 有空即进。当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行有限的时间。
2. 无空则等。当有一个进程在临界区时，其他欲进入临界区的进程必须等待，以保证进程互斥地访问临界资源。
3. 有限等待。对于要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免陷入“饥饿”状态。
4. 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。

### 信号量机制

荷兰学者Djkstat于1965 年提出的信号量机制是一种有效的进程同步与互斥工具。目前，信号量机制有了很大的发展，主要有整型信号量、记录型信号量和信号量集机制。

#### 整型信号量与PV操作

信号量是一个整型变量，根据控制对象的不同被赋予不同的值。信号量分为如下两类:(1)公用信号量。实现进程间的互斥，初值为1或资源的数目。(2)私用信号量。实现进程间的同步，初值为0或某个正整数。

信号量S的物理意义：S≥0 表示某资源的可用数，若S<0,则其绝对值表示阻塞队列中等待该资源的进程数。

对于系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互斥有关。PV操作是实现进程同步与互斥的常用方法。P操作和V操作是低级通信原语，在执行期间不可分割。其中，**P操作表示申请个资源，v操作表示释放一个资源**。

**P操作的定义:** S:=S-1. 若S>=0，则执行P操作的进程继续执行:若S<0,则置该进程为阻塞状态(因为无可用资源)，并将其插入阻塞队列。

P操作可用以下过程表示，其中，Semaphore 表示所定义的变量是信号量。
```
Procedure P(Var S:Semaphore);
	Begin
		S := S - 1;
		if S < 0 then W(S)              {执行P操作的进程插入等待队列}
	End;
```
**V操作的定义:** S:=S+1. 若S>0，则执行V操作的进程继续执行:若S<=0,则从阻塞状态唤醒一个进程，并将其插入就绪队列，然后执行V操作的进程继续。

V操作可用以下过程表示。
```
Procedure V(Var S:Semaphore);
	Begin
		S := S + 1;
		if S <= 0 then R(S)              {从阻塞队列中唤醒一个进程}
	End;
```
用流程图表示PV操作，如下：

<div align=center>
<img src="https://img-blog.csdnimg.cn/20190327095850407.png" width="80%" height="80%" />
</div>


#### 利用PV操作实现进程的互斥

令信号量 mutex 的初值为1，当进入临界区时执行P操作，退出临界区时执行V操作。这样利用PV操作实现进程的互斥的代码段如下:
```
P(mutex)
	临界区
V(mutex)
```
然而，PV操作属于低级通信方式，使用不当容易引起**死锁**。

## 死锁

进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。

所谓死锁，是指两个以上的进程互相都要求对方已经占有的资源导致无法继续运行下去的现象。如果一个进程在等待件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。

例如：
> 系统有三个进程A、B、C，每个进程需要3个系统资源，而系统总共有6个资源，如果把这6个资源平均分配，每个进程2个，则三个进程都不满足运行条件，而系统没有多余的资源分配，三个进程各自占有的资源也不会释放出来分配个其他进程，这就造成了死锁现象。

**死锁产生有四个必要条件：**
1. 互斥条件
2. 请求保持条件
3. 不可剥夺条件
4. 环路条件

当发生死锁时，在进程资源有向图中必构成环路，其中每个资源占有了下一个进程申请的一个或多个资源。

### 死锁的处理

死锁的处理策略只要有四种：鸵鸟策略（不理睬策略）、预防策略、避免策略、检测与解除死锁。

#### 死锁预防

死锁预防是采用某种策略限制并发进程对资源的请求，破坏死锁产生的4个必要条件之一，使系统在任何时刻都不满足死锁的必要条件。预防死锁的两种策略如下。

1. 预先静态分配法。破坏了“不可剥夺条件”， 预先分配所需资源，保证不等待资源。该方法的问题是降低了对资源的利用率，降低进程的并发程度;有时可能无法预先知道所需资源。
2. 资源有序分配法。破坏了“环路条件”，把资源分类按顺序排列，保证不形成环路，该方法存在的问题是限制进程对资源的请求;由于资源的排序占用系统开销。

#### 死锁避免

死锁预防是设法破坏产生死锁的4个必要条件之一，严格防止死锁的产生。死锁避免则不那么严格地限制产生死锁的必要条件。最著名的死锁避免算法是Dijkstra(对，又是他)提出的银行家算法，死锁避免算法需要很大的系统开销。

**银行家算法** 对于进程发出的每--个系统可以满足的资源请求命令加以检测，如果发现分配资源后系统进入不安全状态，则不予分配；若分配资源后系统仍处于安全状态，则实施分配。与死锁预防策略相比，它提高了资源的利用率，但检测分配资源后系统是否安全增加了系统开销。

所谓安全状态，是指系统能按某种顺序如< P1,P2,......,Pn >来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成。通常称< P1,P2,......,Pn >序列为安全序列。若系统不存在这样一个安全序列，则称系统处于不安全状态。

> 假设系统中有三类互斥资源R1、R2和R3，可用资源数分别为8、7和4。在T0时刻系统中有P1、P2、P3、P4和P5，这5个进程，这些进程对资源的最大需求量和已分配资源数如下图所示。
> <div align=center>
> <img src="https://img-blog.csdnimg.cn/20190327104509580.png" width="80%" height="80%" />
> </div>
> 那么进程按什么序列执行，系统状态是安全?
> 
> 答案是：P4 => P2 => P5 => P1 => P3

## 线程

传统的进程有两个基本属性：
- 可拥有资源的独立单位
- 可独立调度和分配的基本单位

引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。

引入线程后，将传统进程的两个基本属性分开，**线程作为调度和分配的基本单位，进程作为独立分配咨源的单位**。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。

例如，在文件服务进程中可设置多个服务线程，当一个线程受阻时，第二个线程可以继续运行，当第二个线程受阻时，第三个线程可以继续运行......从而显著地提高了文件系统的服务质量及系统的吞吐量。

这样，对于拥有资源的基本单位，不用频繁地切换，进步提高了系统中各程序的并发程度。需要说明的是，**线程是进程中的一个实体，是被系统独立分配和调度的基本单位**。线程基本上不拥有资源，只拥有一点运行中必不可少的资源(如程序计数器、一组寄存 器和栈),它可与同属一个进程的其他线程共享进程所拥有的全部资源。

线程也具有就绪、运行和阻塞3种基本状态。由于线程具有许多传统进程所具有的特性，故称为“轻型进程(Light-Weight Process)”: 传统进程称为“重型进程( Heavy-Weight Process)"。线程可创建另一个线程，同一个进程中的多个线程可并发执行。

线程分为用户级线程(User-Level Threads) 和内核支持线程(Kermel-Supported Threads)两类。用户级线程不依赖于内核，该类线程的创建、撤销和切换都不利用系统调用来实现:内核支持线程依赖于内核，即无论是在用户进程中的线程，还是在系统中的线程，它们的创建、撒销和切换都利用系统调用来实现。某些系统同时实现了两种类型的线程。

与线程不同的是，不论是系统进程还是用户进程，在进行切换时，都要依赖于内核中的进程调度。因此，不论是什么进程都是与内核有关的，是在内核支持下进行切换的。尽管线程和进程表面上看起来相似，但它们在本质上是不同的。




